# 2

## 1.为什么开始启动计算机的时候，执行的是BIOS代码而不是操作系统自身的代码？

- 内存没有东西？。

- ---

- 加电的一瞬间，计算机的内存（RAM）中没有程序，虽然软盘里有操作系统，但CPU的逻辑电路被设计为只能运行内存中的程序，必须将操作系统加载到内存中，由BIOS来完成。
  - 具体实现：利用硬件，使CS：IP指向BIOS的入口地址0xFFFF0，BIOS设置实模式下的中断向量表和服务程序，将引导程序bootsect加载至0x7C00（Int 0x19），bootsect复制自身到0x90000，加载setup到0x90200（int 0x13），加载system到0x10000（0x13），最终操作系统位于内存中，被CPU执行。

## 2.为什么BIOS只加载了一个扇区，后续扇区却是由bootsect代码加载？为什么BIOS没有直接把所有需要加载的扇区都加载？

- 简化功能？

- ---

BIOS程序固化在主机板上的 ROM中，根据具体的主机板而不是根据具体的操作系统设计的。操作系统和BIOS通常是由不同的专业团队设计和开发的，为了能协同工作，必须建立操作系统和BIOS之间的协调机制。

两头约定，定位识别：操作系统将最开始执行的程序“定位”在启动扇区，BIOS“约定”接到启动操作系统的命令，“定位识别”只从启动扇区把代码加载到0x7C00.

好处：站在整个体系的高度，统一设计、统一安排、简单有效，BIOS和操作系统可以各自灵活设计。

## 3.为什么BIOS把bootsect加载到0x07c00，而不是0x00000？加载后又马上挪到0x90000处，是何道理？为什么不一次加载到位？

- 厂家约定，并且 BIOS 设置 的 中断处理程序在0x0000？

- ---

- 把bootsect加载到0x07c00：这是根据“两头约定”和“定位识别”而确定的。另外，0x00000处是BIOS中断向量表，后续还需要使用，不能被覆盖。
- 加载到0x90000：这是操作系统开始根据自己的需要安排内存。
- 不一次加载到位：根据“两头约定”和“定位识别”，只能先加载到0x07c00

## 4.bootsect、setup、head程序之间是怎么衔接的？给出代码证据

```cpp
! after that (everyting loaded), we jump to
! the setup-routine loaded directly after
! the bootblock:

 jmpi 0,SETUPSEG

 jmpi 0,8  ! jmp offset 0 of segment 8 (cs)

 lgdt gdt_48  ! load gdt with whatever appropriate


gdt_48:
 .word 0x800  ! gdt limit=2048, 256 GDT entries
 .word 512+gdt,0x9 ! gdt base = 0X9xxxx
 
gdt:
 .word 0,0,0,0  ! dummy

 .word 0x07FF  ! 8Mb - limit=2047 (2048*4096=8Mb)
 .word 0x0000  ! base address=0
 .word 0x9A00  ! code read/exec
 .word 0x00C0  ! granularity=4096, 386
```

## 5.setup程序的最后是jmpi 0,8 ，为什么这个8不能简单的当作阿拉伯数字8看待，究竟有什么内涵？

- 此时处于保护模式下，要根据gdt来决定段的位置。
- gdt 第2项 0特权级。

## 6.保护模式在“保护”什么？它的“保护”体现在哪里？特权级的目的和意义是什么？分页有“保护”作用吗？

- 保护操作系统的安全、不受到恶意攻击、保护进程的地址空间。

- 体现：利用分页、特权级、中断等技术依托CPU提供的硬件机制，对进程调度、内存管理、文件系统等方面进行保护
  - 保护模式下 CPU 通过 GDT表项来获取 代码或数据段的段基址段限长，这阻止了其他

- 特权级的目的和意义：
  - 更好的管理资源并保护系统不受侵害，操作系统利用先机，以时间换取特权，先霸占所有特权；
  - 依托CPU提供的保护模式，着眼于“段”，在所有的段选择符最后两位标示特权级，禁止用户执行cli、sti等对掌控局面至关重要的指令。
  - 操作系统可以把内核设计成最高特权级，把用户进程设计成最低特权级。这样，操作系统可以访问 GDT、LDT、TR，而 GDT、LDT是逻辑地址形成线性地址的关键，因此操作系统可以掌控线性地址。物理地址是由内核将线性地址转换而成的，所以操作系统可以访问任何物理地址，而用户进程只能使用逻辑地址。

- 分页机制有保护作用：
  - 使得用户进程不能直接访问内核地址，进程间也不能相互访问。用户进程只能使用逻辑地址，而逻辑地址通过内核转化为线性地址，根据内核提供的专门为进程设计的分页方案，由MMU非直接映射转化为实际物理地址形成保护。此外，通过分页机制，每个进程都有自己的专属页表，有利于更安全、高效的使用内存，保护每个进程的地址空间。

## 7.在setup程序里曾经设置过gdt，为什么在head程序中将其废弃，又重新设置了一个？为什么设置两次，而不是一次搞好？

- setup所在的位置会被之后的缓冲区 覆盖，
- 如果一次性搞好，那么setup要把gdt设置到main所对应的数据结构中，不好吧。

- ---

- 原来GDT所在的位置是设计代码时在setup.s里面设置的数据，将来这个setup模块所在的内存位置会在设计缓冲区时被覆盖。如果不改变位置，将来GDT的内容肯定会被缓冲区覆盖掉，从而影响系统的运行，这样一来，将来整个内存中唯一安全的地方就是现在head.s所在的位置了。
- 不能直接把GDT内容复制到head.s所在位置：如果先复制GDT，后移动system模块，GDT会被覆盖，如果县移动system模块，后复制GDT，它又会把head.s对应的程序覆盖，而这时head.s还没有执行。
所以，无论如何，要重新建立GDT。

## 8.内核的线性地址空间是如何分页的？画出从0x000000开始的7个页（包括页目录表、页表所在页）的挂接关系图，就是页目录表的前四个页目录项、第一个个页表的前7个页表项指向什么位置？给出代码证据

- 直接对应？
- 第一个页是页目录表，后四个是前16MB的分页。
- 第一个页表的前7个页表项 分别指向 0, 4k, 8k ....

- ```cpp
    setup_paging:
    movl $1024*5,%ecx  /* 5 pages - pg_dir+4 page tables */
    xorl %eax,%eax
    xorl %edi,%edi   /* pg_dir is at 0x000 */
    cld;rep;stosl
    movl $pg0+7,_pg_dir  /*set present bit/user r/w */
    movl $pg1+7,_pg_dir+4  /*  --------- " " --------- */
    movl $pg2+7,_pg_dir+8  /*  --------- " " --------- */
    movl $pg3+7,_pg_dir+12  /*  --------- " " --------- */
    movl $pg3+4092,%edi
    movl $0xfff007,%eax  /*  16Mb - 4096 + 7 (r/w user,p) */
    std
    1: stosl   /* fill pages backwards - more efficient :-) */
    subl $0x1000,%eax
    jge 1b
    xorl %eax,%eax  /* pg_dir is at 0x0000 */
    movl %eax,%cr3  /* cr3 - page directory start */
    movl %cr0,%eax
    orl $0x80000000,%eax
    movl %eax,%cr0  /* set paging (PG) bit*/
    re


## 9.根据内核分页为线性地址恒等映射的要求，推导出四个页表的映射公式，写出页表的设置代码

## 10.为什么不用call，而是用ret“调用”main函数？画出调用路线图，给出代码证据

- 不用call。
